diff '--exclude=.*' -Naur main/c/acmp.c main-count/c/acmp.c
--- main/c/acmp.c	2017-03-27 18:01:08.861738833 +0800
+++ main-count/c/acmp.c	2017-03-27 10:03:51.046584985 +0800
@@ -76,19 +76,17 @@
 						) ;
 
 	while( !( ACMP1->STATUS & ACMP_STATUS_ACMPACT ) ) ;
-
+
 	vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
-	vGPIO_SetMode( DEF_GPIO_PMIC_ON_OFF_REQ , DEF_GPIO_MODE_PUSHPULL ) ;
+	vGPIO_SetMode( DEF_GPIO_PMIC_ON_OFF_REQ , DEF_GPIO_MODE_WIREDAND ) ;
 
 	if( ACMP0->STATUS & ACMP_STATUS_ACMPOUT )
 	{
-		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , HIGH ) ;
 		bPowerSource = DEF_COMMON_POWER_SOURCE_DC ;
 		vPower_SetPowerNeedOn( ) ;
 	}
 	else
 	{
-		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
 		bPowerSource = DEF_COMMON_POWER_SOURCE_CELL_BATTERY ;
 	}
 
diff '--exclude=.*' -Naur main/c/acmp.c~ main-count/c/acmp.c~
--- main/c/acmp.c~	1970-01-01 08:00:00.000000000 +0800
+++ main-count/c/acmp.c~	2017-03-23 16:40:35.924151787 +0800
@@ -0,0 +1,95 @@
+#define DEF_IS_ACMP_C
+#include "common.h"
+
+/* ---------------------------------------------------------------------
+ * Define
+--------------------------------------------------------------------- */
+#define DEF_ACMP_DC_IN_VOLTAGE           3.1 //3.1V
+#define DEF_ACMP_CR2032_MINMUM_VOLTAGE   2.4 //2.4V
+
+/* ---------------------------------------------------------------------
+ * Macro
+--------------------------------------------------------------------- */
+#define mACMP_CalCR2032VDDLevel( mDCINVoltage , mCR2032MinVoltage ) ((uint8_t)(((float)mCR2032MinVoltage*63.0)/(float)mDCINVoltage))
+
+/* ---------------------------------------------------------------------
+ * Function
+--------------------------------------------------------------------- */
+/* ---------------------------------------------------------------------
+ * ACMP Interrupt Handler for DC IN
+--------------------------------------------------------------------- */
+void ACMP0_IRQHandler( void )
+{
+	ACMP0->IFC = ACMP_IFC_EDGE ;
+	if( ACMP0->STATUS & ACMP_STATUS_ACMPOUT )
+	{
+		bPowerSource = DEF_COMMON_POWER_SOURCE_DC ;
+		vPower_SetPowerNeedOn( ) ;
+	}
+	else
+	{
+		bPowerSource = DEF_COMMON_POWER_SOURCE_CELL_BATTERY ;
+	}
+}
+
+/* ---------------------------------------------------------------------
+ * ACMP Initial
+ * ACMP0 is DC IN
+ * ACMP1 is Cell Battery
+--------------------------------------------------------------------- */
+void vACMP_Init( void )
+{
+	CMU->HFPERCLKEN0 |= CMU_HFPERCLKEN0_ACMP1 | CMU_HFPERCLKEN0_ACMP0 ;
+  
+	ACMP0->INPUTSEL = ( ACMP_INPUTSEL_NEGSEL_2V5 | 
+						ACMP_INPUTSEL_POSSEL_CH0 | 
+						ACMP_INPUTSEL_LPREF
+						) ;
+
+	ACMP0->CTRL     = ( ACMP_CTRL_BIASPROG_DEFAULT   |
+						ACMP_CTRL_HYSTSEL_HYST7      |
+						ACMP_CTRL_HALFBIAS           |
+						ACMP_CTRL_WARMTIME_256CYCLES |
+						ACMP_CTRL_IFALL_ENABLED      |
+						ACMP_CTRL_IRISE_ENABLED      |
+						ACMP_CTRL_EN
+						) ;
+  
+	ACMP0->IEN |= ACMP_IEN_EDGE ;
+
+	while( !( ACMP0->STATUS & ACMP_STATUS_ACMPACT ) ) ;
+	NVIC_EnableIRQ( ACMP0_IRQn ) ;
+  
+
+	ACMP1->INPUTSEL = ( ACMP_INPUTSEL_NEGSEL_VDD | 
+						( mACMP_CalCR2032VDDLevel( DEF_ACMP_DC_IN_VOLTAGE , DEF_ACMP_CR2032_MINMUM_VOLTAGE ) << _ACMP_INPUTSEL_VDDLEVEL_SHIFT ) |
+						ACMP_INPUTSEL_POSSEL_CH6 |
+						ACMP_INPUTSEL_LPREF
+						) ;
+
+	ACMP1->CTRL     = (
+						ACMP_CTRL_BIASPROG_DEFAULT   |
+						ACMP_CTRL_HYSTSEL_HYST7      |
+						ACMP_CTRL_HALFBIAS           |
+						ACMP_CTRL_WARMTIME_256CYCLES |
+						ACMP_CTRL_EN
+						) ;
+
+	while( !( ACMP1->STATUS & ACMP_STATUS_ACMPACT ) ) ;
+
+	vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
+	vGPIO_SetMode( DEF_GPIO_PMIC_ON_OFF_REQ , DEF_GPIO_MODE_WIREDAND ) ;
+
+	if( ACMP0->STATUS & ACMP_STATUS_ACMPOUT )
+	{
+		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , HIGH ) ;
+		bPowerSource = DEF_COMMON_POWER_SOURCE_DC ;
+		vPower_SetPowerNeedOn( ) ;
+	}
+	else
+	{
+		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
+		bPowerSource = DEF_COMMON_POWER_SOURCE_CELL_BATTERY ;
+	}
+
+}
diff '--exclude=.*' -Naur main/c/adc.c~ main-count/c/adc.c~
--- main/c/adc.c~	1970-01-01 08:00:00.000000000 +0800
+++ main-count/c/adc.c~	2017-03-16 13:14:36.073583139 +0800
@@ -0,0 +1,54 @@
+#define DEF_IS_ADC_C
+#include "common.h"
+
+/* ---------------------------------------------------------------------
+ * Define
+--------------------------------------------------------------------- */
+#define DEF_ADC_PMIC_VOLTAGE_MAX 		3000 //2.9V
+#define DEF_ADC_PMIC_VOLTAGE_MIN 		2000 //2.4V
+
+#define DEF_ADC_PMIC_RES1 				10 		//10K
+#define DEF_ADC_PMIC_RES2 				10 		//10K
+#define DEF_ADC_REFERENCE_VOLTAGE 		2500
+
+/* ---------------------------------------------------------------------
+ * Value / Data
+--------------------------------------------------------------------- */
+volatile uint32_t u32ADCPMICVoltage  = 0 ;
+volatile bool     bADCVoltageGotFlag = NO ;
+
+/* ---------------------------------------------------------------------
+ * Function
+--------------------------------------------------------------------- */
+void ADC0_IRQHandler( void )
+{
+	uint32_t adData = ADC0->SINGLEDATA ;
+	
+	u32ADCPMICVoltage  = ( adData * DEF_ADC_REFERENCE_VOLTAGE / 4096 ) * ( ( DEF_ADC_PMIC_RES1 + DEF_ADC_PMIC_RES2 ) / DEF_ADC_PMIC_RES2 ) ;
+	bADCVoltageGotFlag = YES ;
+	ADC0->IFC          = ADC_IFC_SINGLE ;
+}
+
+void vADC_Init( void )
+{
+	CMU->HFPERCLKEN0 |= CMU_HFPERCLKEN0_ADC0 ;
+	ADC0->CTRL       |= ( ADC_CTRL_OVSRSEL_X4096 | ADC_CTRL_LPFMODE_RCFILT ) ;
+	ADC0->SINGLECTRL |= ( ADC_SINGLECTRL_INPUTSEL_CH7 | ADC_SINGLECTRL_REF_2V5 | ADC_SINGLECTRL_AT_32CYCLES | ADC_SINGLECTRL_RES_DEFAULT ) ;
+	ADC0->IEN         = ADC_IEN_SINGLE ;
+	NVIC_EnableIRQ( ADC0_IRQn ) ;
+}
+
+bool bADC_PMICVoltageIsOK( void )
+{
+	bADCVoltageGotFlag = NO ;
+	ADC0->CMD          = ADC_CMD_SINGLESTART ;
+	
+	while( bADCVoltageGotFlag != YES ) ;
+	
+	if( u32ADCPMICVoltage >= DEF_ADC_PMIC_VOLTAGE_MIN && u32ADCPMICVoltage <= DEF_ADC_PMIC_VOLTAGE_MAX )
+	{
+		return ( true ) ;
+	}
+	
+	return ( false ) ;
+}
diff '--exclude=.*' -Naur main/c/gpio.c main-count/c/gpio.c
--- main/c/gpio.c	2017-03-27 18:01:08.861738833 +0800
+++ main-count/c/gpio.c	2017-03-23 16:31:58.240167082 +0800
@@ -119,7 +119,7 @@
 		vGPIO_Write( DEF_GPIO_POWER_ON , LOW ) ;
 	}
 	vGPIO_SetMode( DEF_GPIO_POWER_ON , DEF_GPIO_MODE_PUSHPULL ) ;
-	
+	vGPIO_SetMode( DEF_GPIO_POR , DEF_GPIO_MODE_WIREDAND ) ;
 	/* Power Button */
 	vGPIO_SetMode( DEF_GPIO_POWER_BUTTON , DEF_GPIO_MODE_INPUT ) ;
 }
diff '--exclude=.*' -Naur main/c/gpio.c~ main-count/c/gpio.c~
--- main/c/gpio.c~	1970-01-01 08:00:00.000000000 +0800
+++ main-count/c/gpio.c~	2017-03-21 16:46:33.102941339 +0800
@@ -0,0 +1,126 @@
+#define DEF_IS_GPIO_C
+#include "common.h"
+
+void vGPIO_SetMode( uint32_t u32PortBit , uint32_t u32Mode )
+{
+	volatile uint32_t *pu32Adr ;
+	uint32_t u32Port  ;
+	uint32_t u32Bit   ;
+	uint32_t u32Mask  ;
+	uint32_t u32Shift ;
+	
+	u32Port = ((u32PortBit & 0xF0) >> 4) ;
+	u32Bit  = (u32PortBit & 0x0F) ;
+	
+	if ( u32Bit >= 8 )
+	{
+		pu32Adr = (uint32_t *)&GPIO->P[u32Port].MODEH ;
+		u32Bit    = u32Bit - 8 ;
+	}
+	else
+	{
+		pu32Adr = (uint32_t *)&GPIO->P[u32Port].MODEL ;
+	}
+	u32Shift = u32Bit * 4 ;
+	u32Mask = ~(0x0F << u32Shift) ;
+	
+	*pu32Adr = ( *pu32Adr & u32Mask ) | ( u32Mode << u32Shift ) ;
+}
+
+void vGPIO_SetInterrupt( uint32_t u32PortBit , uint32_t u32Mode )
+{
+	volatile uint32_t *pu32Adr ;
+	uint32_t u32Port    ;
+	uint32_t u32Bit     ;
+	uint32_t u32TempBit ;
+	uint32_t u32Mask    ;
+	uint32_t u32Shift   ;
+	
+	u32Port = ((u32PortBit & 0xF0) >> 4) ;
+	u32Bit  = (u32PortBit & 0x0F) ;
+	
+	if ( u32Bit >= 8 )
+	{
+		pu32Adr = (uint32_t *)&GPIO->EXTIPSELH ;
+		u32TempBit = u32Bit - 8 ;
+	}
+	else
+	{
+		pu32Adr = (uint32_t *)&GPIO->EXTIPSELL ;
+		u32TempBit = u32Bit ;
+	}
+	
+	u32Shift = u32TempBit * 4 ;
+	u32Mask = ~(0x07 << u32Shift) ;
+	
+	*pu32Adr = ( *pu32Adr & u32Mask ) | ( u32Port << u32Shift ) ;
+	if ( u32Mode & 0x01 )
+	{
+		GPIO->EXTIFALL  |= ( 1 << u32Bit ) ;
+	}
+	if ( u32Mode & 0x02 )
+	{
+		GPIO->EXTIRISE  |= ( 1 << u32Bit ) ;
+	}
+	GPIO->IFC       |= ( 1 << u32Bit ) ;
+	GPIO->IEN       |= ( 1 << u32Bit ) ;
+}
+
+uint32_t u32GPIO_Read( uint32_t u32PortBit )
+{
+	uint32_t u32Port  ;
+	uint32_t u32Bit   ;
+	
+	u32Port = ((u32PortBit & 0xF0) >> 4) ;
+	u32Bit  = (u32PortBit & 0x0F) ;
+	
+	return ( mCommon_RWMemAddr( mCommon_BitBand( (int)&GPIO->P[u32Port].DIN , u32Bit ) ) ) ;
+}
+
+void vGPIO_Write( uint32_t u32PortBit , uint32_t u32HiLo )
+{
+	uint32_t u32Port  ;
+	uint32_t u32Bit   ;
+	
+	u32Port = ((u32PortBit & 0xF0) >> 4) ;
+	u32Bit  = (u32PortBit & 0x0F) ;
+	
+	mCommon_RWMemAddr( mCommon_BitBand( (int)&GPIO->P[u32Port].DOUT , u32Bit ) ) = u32HiLo ;
+}
+
+void vGPIO_InterruptDisOrEn( uint32_t u32PortBit , uint32_t u32Mode )
+{
+	uint32_t u32Bit   ;
+
+	u32Bit  = (u32PortBit & 0x0F) ;
+	if ( u32Mode )
+	{
+		GPIO->IEN       |= ( 1 << u32Bit ) ;
+	}
+	else
+	{
+		GPIO->IEN       &= ( ~( 1 << u32Bit ) ) ;
+	}
+}
+
+void vGPIO_Init( void )
+{
+	CMU->HFPERCLKEN0 |= CMU_HFPERCLKEN0_GPIO ;
+	GPIO->INSENSE     = GPIO_INSENSE_INT ;
+  
+	/* Power On/Off */
+	vGPIO_SetMode( DEF_GPIO_POWER_ON , DEF_GPIO_MODE_INPUT ) ;
+	if ( u32GPIO_Read( DEF_GPIO_POWER_ON ) )
+	{
+		vGPIO_Write( DEF_GPIO_POWER_ON , HIGH ) ;
+	}
+	else
+	{
+		vGPIO_Write( DEF_GPIO_POWER_ON , LOW ) ;
+	}
+	vGPIO_SetMode( DEF_GPIO_POWER_ON , DEF_GPIO_MODE_PUSHPULL ) ;
+	vGPIO_SetMode( DEF_GPIO_POR , DEF_GPIO_MODE_PUSHPULL ) ;
+	/* Power Button */
+	vGPIO_SetMode( DEF_GPIO_POWER_BUTTON , DEF_GPIO_MODE_INPUT ) ;
+}
+
diff '--exclude=.*' -Naur main/c/i2ccmd.c main-count/c/i2ccmd.c
--- main/c/i2ccmd.c	2017-03-27 18:01:08.861738833 +0800
+++ main-count/c/i2ccmd.c	2017-03-27 15:31:33.150004035 +0800
@@ -43,6 +43,10 @@
 	3 + 16 , // DEF_I2CCMD_MASTER_UPDATE_DATA
 	3 + 12 , // DEF_I2CCMD_MASTER_UPDATE_FINISH
 	3      , // DEF_I2CCMD_MASTER_GET_WHORUN
+	3 + 2  , // DEF_I2CCMD_MASTER_SET_WDOG
+	3 + 1  , // DEF_I2CCMD_MASTER_SET_WDOG_RETRY
+	3 	   , // DEF_I2CCMD_MASTER_GET_WDOG_STATUS
+	3      , // DEF_I2CCMD_MASTER_GET_COUNT
 } ;
 
 /* ---------------------------------------------------------------------
@@ -97,6 +101,28 @@
 	return ( 0 ) ;
 }
 
+int iI2CCmd_SentCount( void )
+{
+	uint8_t u8McuCount[4] = { 0 } ;
+	uint8_t u8Loop ;
+	int     iPutIndex  ;
+	
+	u32Count = u32Count + 1;
+	u8McuCount[3] = u32Count >> 24;
+	u8McuCount[2] = (u32Count >> 16) & 0xff;
+	u8McuCount[1] = (u32Count >> 8) & 0xff;
+	u8McuCount[0] = u32Count & 0xff;
+
+	iPutIndex = DEF_I2CCMD_DATA ;
+	
+	for( u8Loop = 0 ; u8Loop < 4 ; u8Loop++ )
+	{
+		u8I2CSentData[iPutIndex++] = u8McuCount[u8Loop] ;
+	}
+	
+	return ( iI2CCmd_SetData( 4 ) ) ;
+}
+
 int iI2CCmd_GetCalendar( CALENDAR* pCal )
 {
 	uint8_t *pu8Adr    = (uint8_t *)pCal ;
@@ -343,6 +369,27 @@
 	return ( iI2CCmd_SetData( 1 ) ) ;
 }
 
+#ifdef DEF_COMMON_WDOG_FUNCTION
+int iI2CCmd_GetWdog_Status( void )
+{
+	uint8_t *pu8Adr ;
+	int     iIndex     = 0 ;
+
+	pu8Adr = (uint8_t *)&u32PowerWdogSetSec ;
+	for( iIndex = 0 ; iIndex < 2 ; iIndex++ )
+	{
+		u8I2CSentData[DEF_I2CCMD_DATA+iIndex] = pu8Adr[1 - iIndex] ;
+	}
+
+	u8I2CSentData[DEF_I2CCMD_DATA+iIndex] = (uint8_t) u32PowerWdogSetRetryCount;
+	iIndex++;
+	u8I2CSentData[DEF_I2CCMD_DATA+iIndex] = (uint8_t) u32PowerWdogRetryCount;
+	iIndex++;
+	return ( iI2CCmd_SetData( iIndex ) ) ;
+}
+
+#endif
+
 void vI2CCmd_Process( void )
 {
 	vI2C_TimeOut( ) ;
@@ -400,7 +447,23 @@
 					break ;
 				case DEF_I2CCMD_MASTER_GET_WHORUN       :
 					u8I2CSentCmdLen = iI2CCmd_GetWhoRun( ) ;
+					break ;	
+            #ifdef DEF_COMMON_WDOG_FUNCTION
+				case DEF_I2CCMD_MASTER_SET_WDOG          :
+					vPower_SetWdog_Time(u8I2CRecvData[DEF_I2CCMD_DATA], u8I2CRecvData[DEF_I2CCMD_DATA + 1]) ;
+					u8I2CSentCmdLen = iI2CCmd_SentAck( ) ;
 					break ;
+				case DEF_I2CCMD_MASTER_SET_WDOG_RETRY    :
+						vPower_SetWdog_Times(u8I2CRecvData[DEF_I2CCMD_DATA]) ;
+						u8I2CSentCmdLen = iI2CCmd_SentAck( ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_GET_WDOG_STATUS    :
+					u8I2CSentCmdLen = iI2CCmd_GetWdog_Status( ) ;
+					break ;
+            #endif
+				case DEF_I2CCMD_MASTER_GET_COUNT   	:
+					u8I2CSentCmdLen = iI2CCmd_SentCount( ) ;
+					break ;	
 				default:
 					u8I2CSentCmdLen = iI2CCmd_SentNAck( ) ;
 					break ;			
diff '--exclude=.*' -Naur main/c/i2ccmd.c~ main-count/c/i2ccmd.c~
--- main/c/i2ccmd.c~	1970-01-01 08:00:00.000000000 +0800
+++ main-count/c/i2ccmd.c~	2017-03-27 14:03:34.674159997 +0800
@@ -0,0 +1,475 @@
+#define DEF_IS_I2CCMD_C
+#include "common.h"
+
+/* ---------------------------------------------------------------------
+ * Extern
+--------------------------------------------------------------------- */
+extern CALENDAR stcRTCCalendar ;
+extern CALENDAR stcRTCAlarm    ;
+
+extern uint8_t u8I2CRecvData[32] ;
+extern volatile uint8_t u8I2CRecvState ;
+
+extern uint8_t u8I2CSentData[32] ;
+extern volatile uint8_t  u8I2CSentCmdLen ;
+
+/* ---------------------------------------------------------------------
+ * Value
+--------------------------------------------------------------------- */
+uint32_t u32I2CPlainData[4] = { 0 } ;
+
+volatile uint32_t u32I2CFlashAddress  = 0x2000 ;
+volatile uint32_t u32I2CFlashCheckSum = 0 ;
+volatile uint32_t u32I2CFlashOriginCheckSum = 0 ;
+volatile uint32_t u32I2CFlashSize     = 0 ;
+volatile uint8_t  u8I2CFlashState     = 0 ;
+volatile uint32_t u32I2CFlashTimeOut  = 0 ;
+
+/* ---------------------------------------------------------------------
+ * Const
+--------------------------------------------------------------------- */
+uint8_t const u8I2CCmdMaxLen[] = {
+	3 +  6 , // DEF_I2CCMD_MASTER_SET_CLOCK
+	3 +  6 , // DEF_I2CCMD_MASTER_SET_ALARM
+	3      , // DEF_I2CCMD_MASTER_GET_CLOCK
+	3      , // DEF_I2CCMD_MASTER_GET_ALARM
+	3      , // DEF_I2CCMD_MASTER_RESET
+	3 + 16 , // DEF_I2CCMD_MASTER_SENT_AESDATA
+	3      , // DEF_I2CCMD_MASTER_GET_AESDATA
+	3      , // DEF_I2CCMD_MASTER_GET_VERSION
+	3 + 1  , // DEF_I2CCMD_MASTER_SET_POWER_CTL
+	3      , // DEF_I2CCMD_MASTER_GET_POWER_CTL
+	3      , // DEF_I2CCMD_MASTER_UPDATE_START
+	3 + 16 , // DEF_I2CCMD_MASTER_UPDATE_DATA
+	3 + 12 , // DEF_I2CCMD_MASTER_UPDATE_FINISH
+	3      , // DEF_I2CCMD_MASTER_GET_WHORUN
+	3 + 2  , // DEF_I2CCMD_MASTER_SET_WDOG
+	3 + 1  , // DEF_I2CCMD_MASTER_SET_WDOG_RETRY
+	3 	   , // DEF_I2CCMD_MASTER_GET_WDOG_STATUS
+	3      , // DEF_I2CCMD_MASTER_GET_COUNT
+} ;
+
+/* ---------------------------------------------------------------------
+ * Function
+--------------------------------------------------------------------- */
+int iI2CCmd_SentAck( void )
+{
+	u8I2CSentData[DEF_I2CCMD_LEN]  = 3 ;
+	u8I2CSentData[DEF_I2CCMD_CMD]  = DEF_I2CCMD_SLAVE_ACK ;
+	u8I2CSentData[DEF_I2CCMD_DATA] = u8I2CSentData[DEF_I2CCMD_LEN] + u8I2CSentData[DEF_I2CCMD_CMD] ;
+	
+	return ( 3 ) ;
+}
+
+int iI2CCmd_SentNAck( void )
+{
+	u8I2CSentData[DEF_I2CCMD_LEN]  = 3 ;
+	u8I2CSentData[DEF_I2CCMD_CMD]  = DEF_I2CCMD_SLAVE_NACK ;
+	u8I2CSentData[DEF_I2CCMD_DATA] = u8I2CSentData[DEF_I2CCMD_LEN] + u8I2CSentData[DEF_I2CCMD_CMD] ;
+	
+	return ( 3 ) ;
+}
+
+int iI2CCmd_SetData( uint8_t u8Len )
+{
+	int iLoop , iMaxLoop ;
+	uint8_t u8CheckSum ;
+	
+	iMaxLoop = 2 + u8Len ;
+	
+	u8I2CSentData[DEF_I2CCMD_LEN] = 3 + u8Len ;
+	u8I2CSentData[DEF_I2CCMD_CMD] = DEF_I2CCMD_SLAVE_SENT_DATA ;
+	
+	u8CheckSum = u8I2CSentData[DEF_I2CCMD_LEN] + u8I2CSentData[DEF_I2CCMD_CMD] ;
+	
+	for ( iLoop = DEF_I2CCMD_DATA ; iLoop < DEF_I2CCMD_DATA + u8Len ; iLoop ++ )
+	{
+		u8CheckSum += u8I2CSentData[iLoop] ;
+	}
+	
+	u8I2CSentData[iMaxLoop] = u8CheckSum ;
+
+	return ( 3 + u8Len ) ;
+}
+
+int iI2CCmd_CheckCmdIsOK( void )
+{
+	if ( u8I2CRecvData[DEF_I2CCMD_LEN] == u8I2CCmdMaxLen[(u8I2CRecvData[DEF_I2CCMD_CMD]&0x0F)] )
+	{
+		return ( 1 ) ;
+	}
+	return ( 0 ) ;
+}
+
+int iI2CCmd_SentCount( void )
+{
+	uint8_t u8McuCount[4] = { 0 } ;
+	uint8_t u8Loop ;
+	int     iPutIndex  ;
+	
+	u32Count = u32Count + 1;
+	u8McuCount[3] = u32Count >> 24;
+	u8McuCount[2] = (u32Count >> 16) & 0xff;
+	u8McuCount[1] = (u32Count >> 8) & 0xff;
+	u8McuCount[0] = u32Count & 0xff;
+
+	iPutIndex = DEF_I2CCMD_DATA ;
+	
+	for( u8Loop = 0 ; u8Loop < 4 ; u8Loop++ )
+	{
+		u8I2CSentData[iPutIndex++] = u8McuCount[u8Loop] ;
+	}
+	
+	return ( iI2CCmd_SetData( 4 ) ) ;
+}
+
+int iI2CCmd_GetCalendar( CALENDAR* pCal )
+{
+	uint8_t *pu8Adr    = (uint8_t *)pCal ;
+	int     iIndex     = 0 ;
+	
+	for ( iIndex = 0 ; iIndex < sizeof(CALENDAR) ; iIndex ++ )
+	{
+		pu8Adr[iIndex] = u8I2CRecvData[DEF_I2CCMD_DATA+iIndex] ;
+	}
+	return ( iI2CCmd_SentAck( ) ) ;
+}
+
+int iI2CCmd_SendCalendar( CALENDAR* pCal )
+{
+	uint8_t *pu8Adr    = (uint8_t *)pCal ;
+	int     iIndex     ;
+	int     iPutIndex  ;
+	
+	iPutIndex = DEF_I2CCMD_DATA ;
+	for ( iIndex = 0 ; iIndex < sizeof(CALENDAR) ; iIndex ++ )
+	{
+		u8I2CSentData[iPutIndex++] = pu8Adr[iIndex] ;
+	}
+	
+	if ( mACMP_GetCR2032Status( ) )
+	{
+		u8I2CSentData[iPutIndex++] = 1 ;
+	}
+	else
+	{
+		u8I2CSentData[iPutIndex++] = 0 ;
+	}
+	
+	return ( iI2CCmd_SetData( sizeof(CALENDAR) + 1 ) ) ;
+}
+
+int iI2CCmd_GetAESData( void )
+{
+	uint32_t u32InData[4] ;
+	uint8_t *pInData = (uint8_t *)&u32InData[0] ;
+	int iLoop ;
+					
+	for ( iLoop = 0 ; iLoop < 4*4 ; iLoop ++ )
+	{
+		pInData[iLoop] = u8I2CRecvData[DEF_I2CCMD_DATA+iLoop] ;
+	}
+					
+	vAES_128EnDeCrypt( 0 , (uint32_t*)(u8AESKeyData) , (uint32_t*)u32InData , u32I2CPlainData ) ;
+
+	return ( iI2CCmd_SentAck( ) ) ;
+}
+
+int iI2CCmd_SendAESData( void )
+{
+	uint8_t *pu8Adr ;
+	int     iIndex     = 0 ;
+	int     iPutIndex  ;
+	
+	pu8Adr = (uint8_t *)u32I2CPlainData ;
+	iPutIndex = DEF_I2CCMD_DATA ;
+	for( iIndex = 0 ; iIndex < RECEIVE_AES_LENGTH ; iIndex++ )
+	{
+		u8I2CSentData[iPutIndex++] = pu8Adr[iIndex] ;
+	}
+	
+	return ( iI2CCmd_SetData( RECEIVE_AES_LENGTH ) ) ;
+}
+
+int iI2CCmd_SentVersion( void )
+{
+	uint8_t u8Version[4] = SOFTWARE_VERSION ;
+	uint8_t u8Loop ;
+	int     iPutIndex  ;
+	
+	iPutIndex = DEF_I2CCMD_DATA ;
+	
+	for( u8Loop = 0 ; u8Loop < 4 ; u8Loop++ )
+	{
+		u8I2CSentData[iPutIndex++] = u8Version[u8Loop] ;
+	}
+	
+	return ( iI2CCmd_SetData( 4 ) ) ;
+}
+
+int iI2CCmd_SentPowerState( void )
+{
+	if( bPowerFunction )
+	{
+		u8I2CSentData[DEF_I2CCMD_DATA] = 1 ;
+	}
+	else
+	{
+		u8I2CSentData[DEF_I2CCMD_DATA] = 0 ;
+	}
+
+	return ( iI2CCmd_SetData( 1 ) ) ;
+}
+
+int iI2CCmd_GetUpdateStart( void )
+{
+	if ( (uint32_t)&iI2CCmd_GetUpdateStart >= 0x2000 )
+	{
+		u32I2CFlashAddress = 0x400   ;
+		u8I2CSentData[DEF_I2CCMD_DATA] = 0 ;
+	}
+	else
+	{
+		u32I2CFlashAddress = 0x2000 ;
+		u8I2CSentData[DEF_I2CCMD_DATA] = 1 ;
+	}
+	
+	u8I2CFlashState           = 1 ;
+	u32I2CFlashCheckSum       = 0 ;
+	u32I2CFlashSize           = 0 ;
+	u32I2CFlashOriginCheckSum = 0 ;
+
+	vMSC_Init( ) ;
+	
+	return ( iI2CCmd_SetData( 1 ) ) ;
+}
+
+int iI2CCmd_GetUpdateData( void )
+{
+	if ( u8I2CFlashState )
+	{
+		uint32_t u32InData[4] ;
+		uint8_t DeBinData[16] ;
+		uint8_t *pInData = (uint8_t *)&u32InData[0] ;
+		int iLoop ;
+						
+		u8I2CFlashState = 2 ;
+						
+		if( ( u32I2CFlashAddress & 0x1FF ) == 0 )
+		{
+			MSCErase( u32I2CFlashAddress ) ;
+		}
+						
+		for ( iLoop = 0 ; iLoop < 4*4 ; iLoop ++ )
+		{
+			pInData[iLoop] = u8I2CRecvData[DEF_I2CCMD_DATA+iLoop] ;
+			u32I2CFlashCheckSum += u8I2CRecvData[DEF_I2CCMD_DATA+iLoop] ;
+		}
+						
+		vAES_128EnDeCrypt( 0 , (uint32_t*)(u8AESKeyData) , (uint32_t*)pInData , (uint32_t*)&DeBinData[0] ) ;
+		MSCWrite( DeBinData , 16 , &u32I2CFlashAddress ) ;
+		for ( iLoop = 0 ; iLoop < 4*4 ; iLoop ++ )
+		{
+			u32I2CFlashOriginCheckSum += DeBinData[iLoop] ;
+		}
+		u8I2CFlashState = 3 ;
+		u8I2CSentData[DEF_I2CCMD_DATA] = 1 ;
+		u32I2CFlashSize += 16 ;
+	}
+	else
+	{
+		u8I2CSentData[DEF_I2CCMD_DATA] = 0 ;
+	}
+	
+	u32I2CFlashTimeOut = 0 ;
+	
+	return ( iI2CCmd_SetData( 1 ) ) ;
+}
+
+int iI2CCmd_GetUpdateFinish( void )
+{
+	int iOK = 0 ;
+	
+	if ( u8I2CFlashState == 3 )
+	{
+		uint32_t u32GetCheckSum ;
+		uint32_t u32GetOriginCheckSum ;
+		uint32_t u32GetFileSize ;
+		uint8_t *pu8Adr ;
+		int iLoop ;
+		uint32_t u32WriteAdr = 0x200 ;
+		uint8_t u8WriteData[16] ;
+		uint32_t *pAdr = (uint32_t *)&u8WriteData[0] ;
+						
+		pu8Adr = (uint8_t *)&u32GetCheckSum ;
+		for ( iLoop = 0 ; iLoop < 4 ; iLoop ++ )
+		{
+			pu8Adr[iLoop] = u8I2CRecvData[DEF_I2CCMD_DATA+iLoop] ;
+		}
+		
+		pu8Adr = (uint8_t *)&u32GetOriginCheckSum ;
+		for ( iLoop = 4 ; iLoop < 8 ; iLoop ++ )
+		{
+			pu8Adr[iLoop-4] = u8I2CRecvData[DEF_I2CCMD_DATA+iLoop] ;
+		}
+		
+		pu8Adr = (uint8_t *)&u32GetFileSize ;
+		for ( iLoop = 8 ; iLoop < 12 ; iLoop ++ )
+		{
+			pu8Adr[iLoop-8] = u8I2CRecvData[DEF_I2CCMD_DATA+iLoop] ;
+		}
+		
+		if ( u32I2CFlashSize == u32GetFileSize )
+		{
+			if ( u32GetCheckSum == u32I2CFlashCheckSum )
+			{
+				if ( u32GetOriginCheckSum == u32I2CFlashOriginCheckSum )
+				{
+					if ( (uint32_t)&iI2CCmd_GetUpdateFinish >= 0x2000 )
+					{
+						*pAdr = 0x400   ;
+					}
+					else
+					{
+						*pAdr = 0x2000 ;
+					}
+
+					MSCErase( u32WriteAdr ) ;
+					MSCWrite( u8WriteData , 4 , &u32WriteAdr ) ;
+			
+							
+					//vMSC_Release( ) ;
+					//SCB->AIRCR = 0x05FA0004;
+					iOK = 1 ;
+				}
+			}
+		}
+	}
+	
+	u8I2CFlashState    = 0 ;
+	u32I2CFlashTimeOut = 0 ;
+	if ( iOK )
+	{
+		return ( iI2CCmd_SentAck( ) ) ;
+	}
+	return ( iI2CCmd_SentNAck( ) ) ;
+}
+
+int iI2CCmd_GetWhoRun( void )
+{
+	if ( (uint32_t)&iI2CCmd_GetWhoRun >= 0x2000 )
+	{
+		u8I2CSentData[DEF_I2CCMD_DATA] = 1 ;
+	}
+	else
+	{
+		u8I2CSentData[DEF_I2CCMD_DATA] = 0 ;
+	}
+	
+	return ( iI2CCmd_SetData( 1 ) ) ;
+}
+
+#ifdef DEF_COMMON_WDOG_FUNCTION
+int iI2CCmd_GetWdog_Status( void )
+{
+	uint8_t *pu8Adr ;
+	int     iIndex     = 0 ;
+
+	pu8Adr = (uint8_t *)&u32PowerWdogSetSec ;
+	for( iIndex = 0 ; iIndex < 2 ; iIndex++ )
+	{
+		u8I2CSentData[DEF_I2CCMD_DATA+iIndex] = pu8Adr[1 - iIndex] ;
+	}
+
+	u8I2CSentData[DEF_I2CCMD_DATA+iIndex] = (uint8_t) u32PowerWdogSetRetryCount;
+	iIndex++;
+	u8I2CSentData[DEF_I2CCMD_DATA+iIndex] = (uint8_t) u32PowerWdogRetryCount;
+	iIndex++;
+	return ( iI2CCmd_SetData( iIndex ) ) ;
+}
+
+#endif
+
+void vI2CCmd_Process( void )
+{
+	vI2C_TimeOut( ) ;
+	
+	if ( u8I2CRecvState & 0x04 )
+	{
+		I2C0->IEN &= ~DEF_I2C_INT_ENABLE ;
+		u8I2CSentCmdLen = 0 ;
+		if ( iI2CCmd_CheckCmdIsOK( ) )
+		{
+			switch( u8I2CRecvData[DEF_I2CCMD_CMD] )
+			{
+				case DEF_I2CCMD_MASTER_SET_CLOCK     	:
+					u8I2CSentCmdLen = iI2CCmd_GetCalendar( &stcRTCCalendar ) ;
+					vRTC_UpdateCalendar( DEF_RTC_CMD_CLEAR ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_SET_ALARM     	:
+					u8I2CSentCmdLen = iI2CCmd_GetCalendar( &stcRTCAlarm ) ;
+					vRTC_CalculateAlarmCnt( ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_GET_CLOCK     	:
+					vRTC_UpdateCalendar( DEF_RTC_CMD_UPDATE ) ;
+					u8I2CSentCmdLen = iI2CCmd_SendCalendar( &stcRTCCalendar ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_GET_ALARM     	:
+					u8I2CSentCmdLen = iI2CCmd_SendCalendar( &stcRTCAlarm ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_RESET     		:
+					SCB->AIRCR = 0x05FA0004 ;
+					break ;
+				case DEF_I2CCMD_MASTER_SENT_AESDATA 	:
+					u8I2CSentCmdLen = iI2CCmd_GetAESData( ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_GET_AESDATA  	:
+					u8I2CSentCmdLen = iI2CCmd_SendAESData( ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_GET_VERSION   	:
+					u8I2CSentCmdLen = iI2CCmd_SentVersion( ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_SET_POWER_CTL 	:
+					vPower_SetAction( u8I2CRecvData[DEF_I2CCMD_DATA] ) ;
+					u8I2CSentCmdLen = iI2CCmd_SentAck( ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_GET_POWER_CTL 	:
+					u8I2CSentCmdLen = iI2CCmd_SentPowerState( ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_UPDATE_START	 	:
+					u8I2CSentCmdLen = iI2CCmd_GetUpdateStart( ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_UPDATE_DATA		:
+					u8I2CSentCmdLen = iI2CCmd_GetUpdateData( ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_UPDATE_FINISH	:
+					u8I2CSentCmdLen = iI2CCmd_GetUpdateFinish( ) ;
+					break ;
+				case DEF_I2CCMD_MASTER_GET_WHORUN       :
+					u8I2CSentCmdLen = iI2CCmd_GetWhoRun( ) ;
+					break ;	
+            #ifdef DEF_COMMON_WDOG_FUNCTION
+				case DEF_I2CCMD_MASTER_GET_WDOG_STATUS    :
+					u8I2CSentCmdLen = iI2CCmd_GetWdog_Status( ) ;
+					break ;
+            #endif
+				case DEF_I2CCMD_MASTER_GET_COUNT   	:
+					u8I2CSentCmdLen = iI2CCmd_SentCount( ) ;
+					break ;	
+				default:
+					u8I2CSentCmdLen = iI2CCmd_SentNAck( ) ;
+					break ;			
+			}
+		}
+		else
+		{
+			u8I2CSentCmdLen = iI2CCmd_SentNAck( ) ;
+		}
+		vI2C_RecvClear( ) ;
+		I2C0->IEN |= DEF_I2C_INT_ENABLE ;
+	}
+	if ( u8I2CSentCmdLen )
+	{
+		vI2C_StartSend( ) ;
+	}
+}
diff '--exclude=.*' -Naur main/c/power.c main-count/c/power.c
--- main/c/power.c	2017-03-27 18:01:08.865738833 +0800
+++ main-count/c/power.c	2017-03-27 17:50:56.193756935 +0800
@@ -12,9 +12,9 @@
 	PROC_POWER_RESET  ,
 } ;
 
-//Unit:sec
-#define DEF_POWER_BUTTON_POWER_OFF_DETECTION_TIME   1
-#define DEF_POWER_BUTTON_POWER_ON_DETECTION_TIME    1
+//cycle => 5300 => 1Sec
+#define DEF_POWER_BUTTON_POWER_OFF_DETECTION_TIME   5300
+#define DEF_POWER_BUTTON_POWER_ON_DETECTION_TIME    5300
 
 
 /* ---------------------------------------------------------------------
@@ -24,6 +24,7 @@
 uint32_t u32PowerProcCount     = 0 ;
 uint32_t u32PowerProcNextState = 0 ;
 uint32_t u32PowerRTCCount      = 0 ;
+uint32_t u32Count ;
 
 bool     bPowerCanOnFlag       = false ;
 bool     bPowerStatus          = OFF   ;
@@ -34,6 +35,15 @@
 bool     bPowerButtonGet       = 0     ;
 bool     bPowerButtonEvent     = 0     ;
 
+#ifdef DEF_COMMON_WDOG_FUNCTION
+	bool     bPowerWdogOnFlag      = DEF_COMMON_WDOG_ONOFF ;
+	uint32_t u32PowerWdogSetSec    = DEF_COMMON_WDOG_DEFAULT ;
+	uint32_t u32PowerWdogCount     = 0 ;
+
+	uint32_t u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+	uint32_t u32PowerWdogRetryCount = 0;
+#endif
+
 /* ---------------------------------------------------------------------
  * Function
 --------------------------------------------------------------------- */
@@ -72,8 +82,33 @@
 	}
 }
 
+#ifdef DEF_COMMON_WDOG_FUNCTION
+void vPower_SetWdog_Time( uint32_t u32hsec, uint32_t u32lsec )
+{
+	uint32_t u32Act = (u32hsec << 8) + u32lsec;
+	if(u32Act == 0){
+		bPowerWdogOnFlag = false;
+		u32PowerWdogCount = 0;
+		u32PowerWdogSetSec = u32Act;
+
+		u32PowerWdogRetryCount = 0;
+	}else{
+		u32PowerWdogCount = 0;
+		u32PowerWdogSetSec = u32Act;
+		bPowerWdogOnFlag = true;
+	}
+}
+
+void vPower_SetWdog_Times( uint32_t u32count )
+{
+	u32PowerWdogSetRetryCount = u32count;
+}
+
+#endif
+
 void vPower_OffControl( void )
 {
+	vGPIO_Write( DEF_GPIO_POR , LOW ) ;
 	vGPIO_Write( DEF_GPIO_POWER_ON , LOW ) ;
 	vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
 	mI2C_Disable( ) ;
@@ -97,6 +132,13 @@
 		 */
 		if ( bPowerStatus == OFF )
 		{
+			#ifdef DEF_COMMON_WDOG_FUNCTION
+				bPowerWdogOnFlag = DEF_COMMON_WDOG_ONOFF;
+				u32PowerWdogCount = 0;
+				u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+				u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+				u32PowerWdogRetryCount = 0;
+			#endif
 			u32PowerProcState   = PROC_POWER_ON ;
 			u32PowerProcCount   = 0 ;
 			return ;
@@ -119,21 +161,57 @@
 		return ;
 	}
 
+	#ifdef DEF_COMMON_WDOG_FUNCTION
+	if ( bPowerStatus )
+	{
+		u32PowerWdogCount ++ ;
+		if ((u32PowerWdogCount > ( u32PowerWdogSetSec * 5300 )) && bPowerWdogOnFlag)
+		{
+			u32PowerWdogRetryCount ++;
+			if(u32PowerWdogRetryCount > u32PowerWdogSetRetryCount){
+				u32PowerProcState     = PROC_POWER_OFF ;
+			}else{
+				u32PowerProcState     = PROC_POWER_RESET ;
+			}
+			u32PowerProcCount     = 0 ;
+			u32PowerProcNextState = 0 ;
+			u32PowerWdogCount = 0 ;
+			return ;
+		}
+	}
+	else
+	{
+		bPowerWdogOnFlag = false;
+		u32PowerWdogCount = 0;
+		u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+		u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+		u32PowerWdogRetryCount = 0;
+	}
+
+	#endif
+
 }
 
 void vPower_On( void )
 {
-	if ( u32PowerProcCount == 0 )
+	u32PowerProcCount ++ ;
+	
+	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 10 ) )
 	{
-		vGPIO_Write( DEF_GPIO_POWER_ON , HIGH ) ;
-		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , HIGH ) ;		
+		vGPIO_Write( DEF_GPIO_POWER_ON , HIGH ) ;		//step 1 - PowerOn
+	}
+	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 28 ) )
+	{
+		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , HIGH ) ;	//step 2 - delay 18msec (HW request)
+	}	
+	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 600 ) )
+	{
+		vGPIO_Write( DEF_GPIO_POR , HIGH ) ;			//step 3 - POR delay 600msec (HW request)
 	}
 	
-	u32PowerProcCount ++ ;
-	
-	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 100 ) )
+	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 700 ) )
 	{
-		if( bADC_PMICVoltageIsOK( ) )
+		if( bADC_PMICVoltageIsOK( ) )				//step 4 - Detect PMIC
 		{
 			mI2C_Enable( ) ;
 			bPowerStatus = ON ;
@@ -145,7 +223,7 @@
 		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
 	}
 	
-	if ( u32PowerProcCount >= ( DEF_COMMON_FOR_LOOP_TIME_1MS * 150 ) )
+	if ( u32PowerProcCount >= ( DEF_COMMON_FOR_LOOP_TIME_1MS * 750 ) )
 	{
 		u32PowerProcState   = PROC_POWER_OFF ;
 		u32PowerProcCount   = 0 ;
@@ -155,6 +233,13 @@
 
 void vPower_Off( void )
 {
+	#ifdef DEF_COMMON_WDOG_FUNCTION
+		bPowerWdogOnFlag = false;
+		u32PowerWdogCount = 0;
+		u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+		u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+		u32PowerWdogRetryCount = 0;
+	#endif
 	vPower_OffControl( ) ;
 	vPower_DefaultInit( ) ;
 }
@@ -178,7 +263,7 @@
 		u32PowerProcCount   = 0 ;
 		return ;
 	}
-	
+/*	
 	u32RTCNowCount = mRTC_GetCount( ) ;
 	
 	if ( u32PowerProcCount == 0 )
@@ -186,9 +271,9 @@
 		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
 		u32PowerRTCCount = u32RTCNowCount ;
 	}
-	
+*/	
 	u32PowerProcCount ++ ;
-	
+/*	
 	if ( u32RTCNowCount >= u32PowerRTCCount )
 	{
 		u32RTCDiffCount = u32RTCNowCount - u32PowerRTCCount ;
@@ -197,19 +282,34 @@
 	{
 		u32RTCDiffCount = ( 0x1000000 - u32PowerRTCCount ) + u32RTCNowCount ;
 	}
-	
+*/
+//use cycle times 
 	if ( bPowerStatus == OFF )
 	{
-		if ( u32RTCDiffCount >= DEF_POWER_BUTTON_POWER_ON_DETECTION_TIME )
+		if ( u32PowerProcCount >= DEF_POWER_BUTTON_POWER_ON_DETECTION_TIME )
 		{
+			#ifdef DEF_COMMON_WDOG_FUNCTION
+				bPowerWdogOnFlag = DEF_COMMON_WDOG_ONOFF;
+				u32PowerWdogCount = 0;
+				u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+				u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+				u32PowerWdogRetryCount = 0;
+			#endif
 			u32PowerProcState   = PROC_POWER_ON ;
 			u32PowerProcCount   = 0 ;
 		}
 	}
 	else
 	{
-		if ( u32RTCDiffCount >= DEF_POWER_BUTTON_POWER_OFF_DETECTION_TIME )
+		if ( u32PowerProcCount >= DEF_POWER_BUTTON_POWER_OFF_DETECTION_TIME )
 		{
+		#ifdef DEF_COMMON_WDOG_FUNCTION
+			bPowerWdogOnFlag = false;
+			u32PowerWdogCount = 0;
+			u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+			u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+			u32PowerWdogRetryCount = 0;
+		#endif
 			u32PowerProcState   = PROC_POWER_OFF ;
 			u32PowerProcCount   = 0 ;
 		}
@@ -224,8 +324,11 @@
 	}
 	
 	u32PowerProcCount ++ ;
+	#ifdef DEF_COMMON_WDOG_FUNCTION
+		u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+	#endif
 	
-	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 100 ) )
+	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 1000 ) )
 	{
 		u32PowerProcState   = PROC_POWER_ON ;
 		u32PowerProcCount   = 0 ;
diff '--exclude=.*' -Naur main/c/power.c~ main-count/c/power.c~
--- main/c/power.c~	1970-01-01 08:00:00.000000000 +0800
+++ main-count/c/power.c~	2017-03-27 17:50:54.833756975 +0800
@@ -0,0 +1,364 @@
+#define DEF_IS_POWER_C
+#include "common.h"
+
+/* ---------------------------------------------------------------------
+ * Define
+--------------------------------------------------------------------- */
+enum __POWER_STATE__ {
+	PROC_POWER_IDLE   ,
+	PROC_POWER_ON     ,
+	PROC_POWER_OFF    ,
+	PROC_POWER_BUTTON ,
+	PROC_POWER_RESET  ,
+} ;
+
+//cycle => 5300 => 1Sec
+#define DEF_POWER_BUTTON_POWER_OFF_DETECTION_TIME   5300
+#define DEF_POWER_BUTTON_POWER_ON_DETECTION_TIME    5300
+
+
+/* ---------------------------------------------------------------------
+ * Value
+--------------------------------------------------------------------- */
+uint32_t u32PowerProcState     = 0 ;
+uint32_t u32PowerProcCount     = 0 ;
+uint32_t u32PowerProcNextState = 0 ;
+uint32_t u32PowerRTCCount      = 0 ;
+uint32_t u32Count ;
+
+bool     bPowerCanOnFlag       = false ;
+bool     bPowerStatus          = OFF   ;
+bool     bPowerSource          = DEF_COMMON_POWER_SOURCE_CELL_BATTERY ;
+bool     bPowerFunction        = OFF ;
+
+bool     bPowerButtonGetStore  = 0     ;
+bool     bPowerButtonGet       = 0     ;
+bool     bPowerButtonEvent     = 0     ;
+
+#ifdef DEF_COMMON_WDOG_FUNCTION
+	bool     bPowerWdogOnFlag      = DEF_COMMON_WDOG_ONOFF ;
+	uint32_t u32PowerWdogSetSec    = DEF_COMMON_WDOG_DEFAULT ;
+	uint32_t u32PowerWdogCount     = 0 ;
+
+	uint32_t u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+	uint32_t u32PowerWdogRetryCount = 0;
+#endif
+
+/* ---------------------------------------------------------------------
+ * Function
+--------------------------------------------------------------------- */
+void vPower_DefaultInit( void )
+{
+	u32PowerProcState     = 0 ;
+	u32PowerProcCount     = 0 ;
+	u32PowerProcNextState = 0 ;
+	bPowerButtonGetStore  = (!u32GPIO_Read( DEF_GPIO_POWER_BUTTON )) ;
+	bPowerButtonEvent     = 0 ;
+}
+
+void vPower_SetPowerNeedOn( void )
+{
+	bPowerCanOnFlag = true ;
+}
+
+void vPower_SetAction( uint32_t u32Act )
+{
+	switch( u32Act )
+	{
+		case 0 :
+			//power off
+			u32PowerProcNextState = PROC_POWER_OFF ;
+			break ;
+		case 1 :
+			//do reset
+			u32PowerProcNextState = PROC_POWER_RESET ;
+			break ;
+		case 2 :
+			bPowerFunction = ON  ;
+			break ;
+		case 3 :
+			bPowerFunction = OFF ;
+			break ;
+	}
+}
+
+#ifdef DEF_COMMON_WDOG_FUNCTION
+void vPower_SetWdog_Time( uint32_t u32hsec, uint32_t u32lsec )
+{
+	uint32_t u32Act = (u32hsec << 8) + u32lsec;
+	if(u32Act == 0){
+		bPowerWdogOnFlag = false;
+		u32PowerWdogCount = 0;
+		u32PowerWdogSetSec = u32Act;
+
+		u32PowerWdogRetryCount = 0;
+	}else{
+		u32PowerWdogCount = 0;
+		u32PowerWdogSetSec = u32Act;
+		bPowerWdogOnFlag = true;
+	}
+}
+
+void vPower_SetWdog_Times( uint32_t u32count )
+{
+	u32PowerWdogSetRetryCount = u32count;
+}
+
+#endif
+
+void vPower_OffControl( void )
+{
+	vGPIO_Write( DEF_GPIO_POR , LOW ) ;
+	vGPIO_Write( DEF_GPIO_POWER_ON , LOW ) ;
+	vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
+	mI2C_Disable( ) ;
+	bPowerStatus    = OFF ;
+	bPowerCanOnFlag = false ;
+}
+
+void vPower_Idle( void )
+{
+	/*
+	 * Check if need power on
+	 */
+	if ( bPowerCanOnFlag )
+	{
+		mCommon_DisableIrq( ) ;
+		bPowerCanOnFlag = false ;
+		mCommon_EnableIrq( ) ;
+		/*
+		 * Is power on or off now
+		 * If power off , need to open power
+		 */
+		if ( bPowerStatus == OFF )
+		{
+			#ifdef DEF_COMMON_WDOG_FUNCTION
+				bPowerWdogOnFlag = DEF_COMMON_WDOG_ONOFF;
+				u32PowerWdogCount = 0;
+				u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+				u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+				u32PowerWdogRetryCount = 0;
+			#endif
+			u32PowerProcState   = PROC_POWER_ON ;
+			u32PowerProcCount   = 0 ;
+			return ;
+		}
+	}
+	
+	if ( bPowerButtonEvent )
+	{
+		u32PowerProcState   = PROC_POWER_BUTTON ;
+		u32PowerProcCount   = 0 ;
+		bPowerButtonEvent   = false ;
+		return ;
+	}
+
+	if ( u32PowerProcNextState )
+	{
+		u32PowerProcState     = u32PowerProcNextState ;
+		u32PowerProcCount     = 0 ;
+		u32PowerProcNextState = 0 ;
+		return ;
+	}
+
+	#ifdef DEF_COMMON_WDOG_FUNCTION
+	if ( bPowerStatus )
+	{
+		u32PowerWdogCount ++ ;
+		if ((u32PowerWdogCount > ( u32PowerWdogSetSec * 5300 )) && bPowerWdogOnFlag)
+		{
+			u32PowerWdogRetryCount ++;
+			if(u32PowerWdogRetryCount > u32PowerWdogSetRetryCount){
+				u32PowerProcState     = PROC_POWER_OFF ;
+			}else{
+				u32PowerProcState     = PROC_POWER_RESET ;
+			}
+			u32PowerProcCount     = 0 ;
+			u32PowerProcNextState = 0 ;
+			u32PowerWdogCount = 0 ;
+			return ;
+		}
+	}
+	else
+	{
+		bPowerWdogOnFlag = false;
+		u32PowerWdogCount = 0;
+		u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+		u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+		u32PowerWdogRetryCount = 0;
+	}
+
+	#endif
+
+}
+
+void vPower_On( void )
+{
+	u32PowerProcCount ++ ;
+	
+	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 10 ) )
+	{
+		vGPIO_Write( DEF_GPIO_POWER_ON , HIGH ) ;		//step 1 - PowerOn
+	}
+	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 28 ) )
+	{
+		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , HIGH ) ;	//step 2 - delay 18msec (HW request)
+	}	
+	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 600 ) )
+	{
+		vGPIO_Write( DEF_GPIO_POR , HIGH ) ;			//step 3 - POR delay 600msec (HW request)
+	}
+	
+	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 700 ) )
+	{
+		if( bADC_PMICVoltageIsOK( ) )				//step 4 - Detect PMIC
+		{
+			mI2C_Enable( ) ;
+			bPowerStatus = ON ;
+			u32PowerProcState   = PROC_POWER_IDLE ;
+			u32PowerProcCount   = 0 ;
+			return ;
+		}
+		vGPIO_Write( DEF_GPIO_POWER_ON , LOW ) ;
+		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
+	}
+	
+	if ( u32PowerProcCount >= ( DEF_COMMON_FOR_LOOP_TIME_1MS * 750 ) )
+	{
+		u32PowerProcState   = PROC_POWER_OFF ;
+		u32PowerProcCount   = 0 ;
+		return ;
+	}
+}
+
+void vPower_Off( void )
+{
+	#ifdef DEF_COMMON_WDOG_FUNCTION
+		bPowerWdogOnFlag = false;
+		u32PowerWdogCount = 0;
+		u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+		u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+		u32PowerWdogRetryCount = 0;
+	#endif
+	vPower_OffControl( ) ;
+	vPower_DefaultInit( ) ;
+}
+
+void vPower_Button( void )
+{
+	uint32_t u32RTCNowCount ;
+	uint32_t u32RTCDiffCount ;
+	
+	if ( !bPowerButtonGet )
+	{
+		if ( bPowerStatus == OFF )
+		{
+			vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
+		}
+		else
+		{
+			vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , HIGH ) ;
+		}
+		u32PowerProcState   = PROC_POWER_IDLE ;
+		u32PowerProcCount   = 0 ;
+		return ;
+	}
+/*	
+	u32RTCNowCount = mRTC_GetCount( ) ;
+	
+	if ( u32PowerProcCount == 0 )
+	{
+		vGPIO_Write( DEF_GPIO_PMIC_ON_OFF_REQ , LOW ) ;
+		u32PowerRTCCount = u32RTCNowCount ;
+	}
+*/	
+	u32PowerProcCount ++ ;
+/*	
+	if ( u32RTCNowCount >= u32PowerRTCCount )
+	{
+		u32RTCDiffCount = u32RTCNowCount - u32PowerRTCCount ;
+	}
+	else
+	{
+		u32RTCDiffCount = ( 0x1000000 - u32PowerRTCCount ) + u32RTCNowCount ;
+	}
+*/
+//use cycle times 
+	if ( bPowerStatus == OFF )
+	{
+		if ( u32PowerProcCount >= DEF_POWER_BUTTON_POWER_ON_DETECTION_TIME )
+		{
+			#ifdef DEF_COMMON_WDOG_FUNCTION
+				bPowerWdogOnFlag = DEF_COMMON_WDOG_ONOFF;
+				u32PowerWdogCount = 0;
+				u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+				u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+				u32PowerWdogRetryCount = 0;
+			#endif
+			u32PowerProcState   = PROC_POWER_ON ;
+			u32PowerProcCount   = 0 ;
+		}
+	}
+	else
+	{
+		if ( u32PowerProcCount >= DEF_POWER_BUTTON_POWER_OFF_DETECTION_TIME )
+		{
+		#ifdef DEF_COMMON_WDOG_FUNCTION
+			bPowerWdogOnFlag = false;
+			u32PowerWdogCount = 0;
+			u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+			u32PowerWdogSetRetryCount = DEF_COMMON_WDOG_RETRY_DEFAULT;
+			u32PowerWdogRetryCount = 0;
+		#endif
+			u32PowerProcState   = PROC_POWER_OFF ;
+			u32PowerProcCount   = 0 ;
+		}
+	}
+}
+
+void vPower_Reset( void )
+{
+	if ( u32PowerProcCount == 0 )
+	{
+		vPower_OffControl( ) ;
+	}
+	
+	u32PowerProcCount ++ ;
+	#ifdef DEF_COMMON_WDOG_FUNCTION
+		u32PowerWdogSetSec = DEF_COMMON_WDOG_DEFAULT;
+	#endif
+	
+	if ( u32PowerProcCount == ( DEF_COMMON_FOR_LOOP_TIME_1MS * 1000 ) )
+	{
+		u32PowerProcState   = PROC_POWER_ON ;
+		u32PowerProcCount   = 0 ;
+	}
+}
+
+void vPower_Process( void )
+{
+	if( bPowerSource != DEF_COMMON_POWER_SOURCE_DC )
+	{
+		return ;
+	}
+
+	bPowerButtonGet = (!u32GPIO_Read( DEF_GPIO_POWER_BUTTON )) ;
+	if ( bPowerButtonGetStore != bPowerButtonGet )
+	{
+		bPowerButtonGetStore = bPowerButtonGet ;
+		bPowerButtonEvent = true ;
+	}
+	
+	switch( u32PowerProcState )
+	{
+		case PROC_POWER_IDLE   : vPower_Idle( ) ;   break ;
+		case PROC_POWER_ON     : vPower_On( ) ;     break ;
+		case PROC_POWER_OFF    : vPower_Off( ) ;    break ;
+		case PROC_POWER_BUTTON : vPower_Button( ) ; break ;
+		case PROC_POWER_RESET  : vPower_Reset( ) ;  break ;
+		default :
+			u32PowerProcState = PROC_POWER_IDLE ;
+			u32PowerProcCount = 0 ;
+			break ;
+	}
+}
diff '--exclude=.*' -Naur main/h/common.h main-count/h/common.h
--- main/h/common.h	2017-03-27 18:01:08.865738833 +0800
+++ main-count/h/common.h	2017-03-27 17:50:08.841758334 +0800
@@ -12,7 +12,7 @@
 	/* ---------------------------------------------------------------------
 	* Define
 	--------------------------------------------------------------------- */
-	#define SOFTWARE_VERSION 							{'w',16,4,27}
+	#define SOFTWARE_VERSION 							{'t',17,3,27}
 
 	#define HIGH 										1
 	#define LOW  										0
@@ -29,8 +29,13 @@
 	#define DEF_COMMON_POWER_SOURCE_DC      			1
 	#define DEF_COMMON_POWER_SOURCE_CELL_BATTERY 		0
 
-	#define DEF_COMMON_FOR_LOOP_TIME_1MS  				95
+	#define DEF_COMMON_FOR_LOOP_TIME_1MS  				5
+	#define DEF_POWER_AC_IN_DETECTION_TIME  DEF_COMMON_FOR_LOOP_TIME_1MS * 100
 	
+	#define DEF_COMMON_WDOG_FUNCTION
+	#define DEF_COMMON_WDOG_DEFAULT 		            10
+	#define DEF_COMMON_WDOG_ONOFF	 		            true
+	#define DEF_COMMON_WDOG_RETRY_DEFAULT	 		    0
 	/* ---------------------------------------------------------------------
 	* Macro
 	--------------------------------------------------------------------- */
diff '--exclude=.*' -Naur main/h/common.h~ main-count/h/common.h~
--- main/h/common.h~	1970-01-01 08:00:00.000000000 +0800
+++ main-count/h/common.h~	2017-03-27 17:50:03.893758480 +0800
@@ -0,0 +1,63 @@
+#ifndef DEF_IS_COMMON_H
+	#define DEF_IS_COMMON_H
+	
+	/* ---------------------------------------------------------------------
+	* Include MCU
+	--------------------------------------------------------------------- */
+	#include "efm32.h"
+	//#include "config_main.h"
+	#include <stdbool.h>
+	
+	#define __ramfunc __attribute__ ((long_call, section (".textrw")))
+	/* ---------------------------------------------------------------------
+	* Define
+	--------------------------------------------------------------------- */
+	#define SOFTWARE_VERSION 							{'t',17,3,27}
+
+	#define HIGH 										1
+	#define LOW  										0
+
+	#define ON 											1
+	#define OFF 										0
+
+	#define YES 										1
+	#define NO  										0
+	
+	#define DEF_COMMON_HFCLK_FREQUENCY                 	1200000
+	#define DEF_COMMON_HFPERCLK_FREQUENCY              	1200000
+	
+	#define DEF_COMMON_POWER_SOURCE_DC      			1
+	#define DEF_COMMON_POWER_SOURCE_CELL_BATTERY 		0
+
+	#define DEF_COMMON_FOR_LOOP_TIME_1MS  				5
+	#define DEF_POWER_AC_IN_DETECTION_TIME  DEF_COMMON_FOR_LOOP_TIME_1MS * 100
+	
+	#define DEF_COMMON_WDOG_FUNCTION
+	#define DEF_COMMON_WDOG_DEFAULT 		            10
+	#define DEF_COMMON_WDOG_ONOFF	 		            true
+	#define DEF_COMMON_WDOG_RETRY_DEFAULT	 		    0
+	/* ---------------------------------------------------------------------
+	* Macro
+	--------------------------------------------------------------------- */
+	#define mCommon_BitBand( mAddr , mBit ) 			(0x42000000 + (mAddr - 0x40000000)* 32 + mBit * 4)
+	#define mCommon_RWMemAddr( mAddr ) 					*((volatile unsigned long *) (mAddr))
+	
+	#define mCommon_DisableIrq() 						{ __asm( "CPSID I" ) ; }
+	#define mCommon_EnableIrq()							{ __asm( "CPSIE I" ) ; }
+	
+	/* ---------------------------------------------------------------------
+	* include
+	--------------------------------------------------------------------- */	
+	#include "cmu.h"
+	#include "gpio.h"
+	#include "i2c.h"
+	#include "i2ccmd.h"
+	#include "rtc.h"
+	#include "aes.h"
+	#include "acmp.h"
+	//#include "em_chip.h"
+	#include "adc.h"
+	#include "msc.h"
+	#include "power.h"
+
+#endif
diff '--exclude=.*' -Naur main/h/gpio.h main-count/h/gpio.h
--- main/h/gpio.h	2017-03-27 18:01:08.865738833 +0800
+++ main-count/h/gpio.h	2017-03-27 14:20:40.558129685 +0800
@@ -31,10 +31,10 @@
 	#define DEF_GPIO_PMIC_ON_OFF_REQ					0x1B  /* 1 , 11 */
 	#define DEF_GPIO_I2C_SDA 							0x4C  /* 4 , 12 */
 	#define DEF_GPIO_I2C_SCL 							0x4D  /* 4 , 13 */
-
+	#define DEF_GPIO_POR 							0x52  /* 5 , 2 */
 	//Unit:sec
-	#define POWER_BUTTON_POWER_OFF_DETECTION_TIME   1
-	#define POWER_BUTTON_POWER_ON_DETECTION_TIME    1
+//	#define POWER_BUTTON_POWER_OFF_DETECTION_TIME   1
+//	#define POWER_BUTTON_POWER_ON_DETECTION_TIME    1
 	
 	#define mGPIO_GetPort( mPortBit ) 					((mPortBit>>4)&0x0F)
 	#define mGPIO_GetPin( mPortBit ) 					(mPortBit&0x0F)
diff '--exclude=.*' -Naur main/h/i2ccmd.h main-count/h/i2ccmd.h
--- main/h/i2ccmd.h	2017-03-27 18:01:08.865738833 +0800
+++ main-count/h/i2ccmd.h	2017-03-27 13:38:50.378203853 +0800
@@ -32,6 +32,11 @@
 	#define DEF_I2CCMD_MASTER_UPDATE_DATA	 	0x8B
 	#define DEF_I2CCMD_MASTER_UPDATE_FINISH	 	0x8C
 	#define DEF_I2CCMD_MASTER_GET_WHORUN	 	0x8D
+
+	#define DEF_I2CCMD_MASTER_SET_WDOG		0x8E
+	#define DEF_I2CCMD_MASTER_SET_WDOG_RETRY	0x8F
+	#define DEF_I2CCMD_MASTER_GET_WDOG_STATUS	0x90
+	#define DEF_I2CCMD_MASTER_GET_COUNT   		0x92
 	
 	#define DEF_I2CCMD_SLAVE_ACK				0xA0
 	#define DEF_I2CCMD_SLAVE_NACK				0xA1
diff '--exclude=.*' -Naur main/h/power.h main-count/h/power.h
--- main/h/power.h	2017-03-27 18:01:08.865738833 +0800
+++ main-count/h/power.h	2017-03-27 13:40:35.090200759 +0800
@@ -13,8 +13,17 @@
 	EXTERN void vPower_DefaultInit( void ) ;
 	EXTERN void vPower_SetPowerNeedOn( void ) ;
 	EXTERN void vPower_SetAction( uint32_t u32Act ) ;
+	#ifdef DEF_COMMON_WDOG_FUNCTION
+		EXTERN void vPower_SetWdog_Time( uint32_t u32hsec, uint32_t u32lsec ) ;
+		EXTERN void vPower_SetWdog_Times( uint32_t u32times ) ;
+		EXTERN uint32_t u32PowerWdogSetSec;
+		EXTERN uint32_t u32PowerWdogSetRetryCount;
+		EXTERN uint32_t u32PowerWdogRetryCount;
+		EXTERN bool bPowerWdogOnFlag;
+	#endif
 	EXTERN void vPower_OffControl( void ) ;
 	EXTERN void vPower_Process( void ) ;
+	EXTERN uint32_t u32Count ;
 	
 	#undef EXTERN
 #endif
